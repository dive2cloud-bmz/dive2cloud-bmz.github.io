<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="raft, BMZ BLOG">
    <meta name="description" content="前言简单了解直接看 https://thesecretlivesofdata.com/raft/但是这里有一些词语不准确，可能会让人误解。二手理解 blog 80%是一知半解，负分滚粗，我直接看论文英文原文地址 https://ramclo">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>raft | BMZ BLOG</title>
    <link rel="icon" type="image/jpeg" href="/hadoop-icon.jpg">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="BMZ BLOG" type="application/atom+xml">
</head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/hadoop-icon.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">BMZ BLOG</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/hadoop-icon.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">BMZ BLOG</div>
        <div class="logo-desc">
            
            层楼终究误少年
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/dive2cloud-bmz" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/dive2cloud-bmz" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/21.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">raft</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">
                                <span class="chip bg-color">分布式</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2025-03-24
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2025-03-27
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    9.1k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    33 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>简单了解直接看 <a target="_blank" rel="noopener" href="https://thesecretlivesofdata.com/raft/">https://thesecretlivesofdata.com/raft/</a><br>但是这里有一些词语不准确，可能会让人误解。<br>二手理解 blog 80%是一知半解，负分滚粗，我直接看论文<br>英文原文地址 <a target="_blank" rel="noopener" href="https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf">https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf</a><br>中文翻译地址 <a target="_blank" rel="noopener" href="https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md">https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md</a></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>aft 是一个共识算法（consensus algorithm），所谓共识，就是即使是在部分节点故障、网络延时、网络分割的情况下，多个节点对某个事情也能达成一致的看法。<br>raft 是工程上使用较为广泛的强一致性、去中心化、高可用的分布式协议。<br>在 raft 之前工程上最有名的 paxos，但是 paxos 太难理解，很多人读不懂还在出书写博客瞎谈感受误导别人。</p>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>为了易于理解，raft 主要做了两件事：</p>
<ol>
<li>问题分解<br>将复杂问题“复制集中节点一致性”拆分为多个子问题，使得每个子问题可以独立地被解释、理解和解决。在 raft，子问题包括<br>leader election：当前 leader 故障时，必须有一个新 leader 被选举出来<br>log replication：leader 必须从客户端接受 log entires，然后复制到其他节点，并强制要求其他节点的日志与自己相同<br>safety：任何服务器节点已经应用了一个确定的 log entires 到他的状态机中，那么其他节点不能在同一个日志索引位置 apply 一个不同的指令<br>membership changes：有时会变更集群的配置，比如增减节点等，有一个良好的机制不用停服就能做到</li>
<li>状态简化<br>对算法做出一些限制，减少需要考虑的状态数，使得算法更加清晰，更少的不确定性（比如，保证新选举出来的 leader 会包含所有 commited log entry）</li>
</ol>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>先选出 leader，同一时间只有一个leader，leader 完全负责 replicated log 管理。<br>leader 负责接受所有客户端更新请求，请求会记录成日志，然后 leader 复制日志到 follower 节点，并在“安全”的时候执行这些请求。<br>如果 leader 故障，followers 会重新选举出新的 leader。</p>
<h2 id="RAFT-算法特性"><a href="#RAFT-算法特性" class="headerlink" title="RAFT 算法特性"></a>RAFT 算法特性</h2><p>raft 在任何时候都保证下面的特性<br><img src="/.io//03/24/raft/algo.png"></p>
<h3 id="选举安全特性"><a href="#选举安全特性" class="headerlink" title="选举安全特性"></a>选举安全特性</h3><p>对于一个给定的任期号，最多只会有一个领导人被选举出来</p>
<h3 id="领导人只附加原则"><a href="#领导人只附加原则" class="headerlink" title="领导人只附加原则"></a>领导人只附加原则</h3><p>领导人绝对不会删除或者覆盖自己的日志，只会增加</p>
<h3 id="日志匹配原则"><a href="#日志匹配原则" class="headerlink" title="日志匹配原则"></a>日志匹配原则</h3><p>如果两个日志在某一相同索引位置日志条目的任期号相同，那么我们就认为这两个日志从头到该索引位置之间的内容完全一致</p>
<h3 id="领导人完全特性"><a href="#领导人完全特性" class="headerlink" title="领导人完全特性"></a>领导人完全特性</h3><p>如果某个日志条目在某个任期号中已经被提交，那么这个条目必然出现在更大任期号的所有领导人中</p>
<h3 id="状态机安全特性"><a href="#状态机安全特性" class="headerlink" title="状态机安全特性"></a>状态机安全特性</h3><p>如果某一服务器已将给定索引位置的日志条目应用至其状态机中，则其他任何服务器在该索引位置不会应用到不同的日志条目</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><p>raft 协议中，一个节点任一时刻处于以下三个状态之一：</p>
<ol>
<li>leader</li>
<li>follower</li>
<li>candidate</li>
</ol>
<p>给出状态转移图能很直观的直到这三个状态的区别<br><img src="/.io//03/24/raft/state.png"><br>可以看出所有节点启动时都是 follower 状态；<br>在一段时间内如果没有收到来自 leader 的心跳，从 follower 切换到 candidate，发起选举；<br>如果收到 majority 的造成票（含自己的一票）则切换到 leader 状态；<br>如果发现其他节点比自己更新，则主动切换到 follower。<br>总结一下：<br>系统中最多只有一个 leader，如果在一段时间里发现没有 leader，则大家通过选举-投票选出 leader。<br>leader 会不停地给 follower 发心跳消息，表明自己的存活状态。<br>如果 leader 故障，那么 follower 会转换成 candidate，重新选出 leader。</p>
<h3 id="term"><a href="#term" class="headerlink" title="term"></a>term</h3><p>从上面可以看出，哪个节点做 leader 是大家投票选举出来的，每个 leader 工作一段时间，然后选出新的 leader 继续负责。<br>这跟民主社会的选举很像，每一届新的履职期称之为一届任期，在 raft 协议中，也是这样的，对应的术语叫 term。<br><img src="/.io//03/24/raft/term.png"><br>term（任期）以选举（election）开始，然后就是一段或长或短的稳定工作期（normal Operation）。从上图可以看到，任期是递增的，这就充当了逻辑时钟的作用；另外，term 3 展示了一种情况，就是说没有选举出 leader 就结束了，然后会发起新的选举，后面会解释这种 split vote 的情况。</p>
<h2 id="leader-election"><a href="#leader-election" class="headerlink" title="leader election"></a>leader election</h2><p>服务器刚启动时，全部节点都是 follower；<br>当 follower 经过一段时间后还没有接到任何RPC（选举超时），那么他就认为系统中没有 leader，自己开始发起选举；<br>leader 会周期性的发送 appendEntries rpcs 来维持权威；</p>
<h3 id="选举过程"><a href="#选举过程" class="headerlink" title="选举过程"></a>选举过程</h3><p>如果 follower 在 election timeout 内没有收到来自 leader 的心跳，（也许此时还没有选出 leader，大家都在等；也许 leader 挂了；也许只是 leader 与该 follower 之间网络故障），则会主动发起选举。步骤如下：</p>
<ol>
<li>增加节点本地的 current term，同时自己变成 candidate 状态</li>
<li>投自己一票</li>
<li>投自己同时给其他节点发送 RequestVote rpcs</li>
<li>等待其他节点回复<br>这个过程会有 3 种结果：<br>a. 收到 majority (含自己) 的投票，自己成为leader<br>b. 收到 leader 的 appendEntires RPC，假如请求中携带的 term &gt;&#x3D; 自己，自己切换回 follower；假如 term &lt; 自己，那么他将回复拒绝并保持 candidate 状态<br>c. 一段时间内没有收到足够 majority 的投票，从新发起选举</li>
</ol>
<hr>
<h2 id="在-a-情况下，赢得选举后会立刻广播给所以节点自己是leader-的消息，避免其他节点触发新选举。在这里，先回到投票者的视角，投票者如何决定是否给一个选举请求投票呢，有以下约束：i-在任何-term-中，一个节点至多投一票ii-candidate-信息-当前节点，否则拒绝投票给他（log-replication-和-safety-时介绍为什么）iii-first-come-first-served，谁选来谁算数"><a href="#在-a-情况下，赢得选举后会立刻广播给所以节点自己是leader-的消息，避免其他节点触发新选举。在这里，先回到投票者的视角，投票者如何决定是否给一个选举请求投票呢，有以下约束：i-在任何-term-中，一个节点至多投一票ii-candidate-信息-当前节点，否则拒绝投票给他（log-replication-和-safety-时介绍为什么）iii-first-come-first-served，谁选来谁算数" class="headerlink" title="在 a 情况下，赢得选举后会立刻广播给所以节点自己是leader 的消息，避免其他节点触发新选举。在这里，先回到投票者的视角，投票者如何决定是否给一个选举请求投票呢，有以下约束：i. 在任何 term 中，一个节点至多投一票ii. candidate 信息 &gt;&#x3D; 当前节点，否则拒绝投票给他（log replication 和 safety 时介绍为什么）iii. first come first served，谁选来谁算数"></a>在 a 情况下，赢得选举后会立刻广播给所以节点自己是leader 的消息，避免其他节点触发新选举。<br>在这里，先回到投票者的视角，投票者如何决定是否给一个选举请求投票呢，有以下约束：<br>i. 在任何 term 中，一个节点至多投一票<br>ii. candidate 信息 &gt;&#x3D; 当前节点，否则拒绝投票给他（log replication 和 safety 时介绍为什么）<br>iii. first come first served，谁选来谁算数</h2><h2 id="在-b-情况下，比如有三个节点A-B-C。A-B同时发起选举，而A的选举消息先到达C，C给A投了一票，当B的消息到达C时，已经不能满足上面提到的第一个约束，即C不会给B投票，而A和B显然都不会给对方投票。A胜出之后，会给B-C发心跳消息，节点B发现节点A的term不低于自己的term，知道有已经有Leader了，于是转换成follower。"><a href="#在-b-情况下，比如有三个节点A-B-C。A-B同时发起选举，而A的选举消息先到达C，C给A投了一票，当B的消息到达C时，已经不能满足上面提到的第一个约束，即C不会给B投票，而A和B显然都不会给对方投票。A胜出之后，会给B-C发心跳消息，节点B发现节点A的term不低于自己的term，知道有已经有Leader了，于是转换成follower。" class="headerlink" title="在 b 情况下，比如有三个节点A B C。A B同时发起选举，而A的选举消息先到达C，C给A投了一票，当B的消息到达C时，已经不能满足上面提到的第一个约束，即C不会给B投票，而A和B显然都不会给对方投票。A胜出之后，会给B,C发心跳消息，节点B发现节点A的term不低于自己的term，知道有已经有Leader了，于是转换成follower。"></a>在 b 情况下，比如有三个节点A B C。A B同时发起选举，而A的选举消息先到达C，C给A投了一票，当B的消息到达C时，已经不能满足上面提到的第一个约束，即C不会给B投票，而A和B显然都不会给对方投票。A胜出之后，会给B,C发心跳消息，节点B发现节点A的term不低于自己的term，知道有已经有Leader了，于是转换成follower。</h2><p>在 c 情况，没有任何节点获得majority投票，比如下图这种情况<br><img src="/.io//03/24/raft/no-majority.png"><br>总共有四个节点，Node C、Node D同时成为了candidate，进入了term 4，但 Node A 投了 NodeD 一票，NodeB 投了 Node C一票，这就出现了平票 split vote的情况。<br>这个时候大家都在等啊等，直到超时后重新发起选举。<br>如果出现平票的情况，那么就延长了系统不可用的时间（没有leader是不能处理客户端写请求的），因此raft引入了 randomized election timeouts 来尽量避免平票情况。<br>同时，leader-based 共识算法中，节点的数目都是奇数个，尽量保证majority的出现。</p>
<h3 id="random-eletion-timeout"><a href="#random-eletion-timeout" class="headerlink" title="random eletion timeout"></a>random eletion timeout</h3><p>为了减少平票轮次过多，导致 leader 总是选不出来，在节点进入 candidate 时有一个固定的选举超时时间（150-300ms随机），这分散大家发起选举的间隔，让大多数情况下只有一个节点会选举超时（随机时间最小的节点），他将发起第二次选举，此时他的 term 是最大的，他将最先赢得其他节点的选票，并在其他 candidate 第一次选举超时之前发送他的 leader 心跳；<br>下图是一个5节点集群的leader宕机导致选举时间图。<br><img src="/.io//03/24/raft/leader-down.png"><br>上面的图表明，只需要在选举超时时间上使用很少的随机化就可以大大避免选票被瓜分的情况。在没有随机化的情况下，在我们的测试里，选举过程往往都需要花费超过 10 秒钟由于太多的选票瓜分的情况。仅仅增加 5 毫秒的随机化时间，就大大的改善了选举过程，现在平均的宕机时间只有 287 毫秒。增加更多的随机化时间可以大大改善最坏情况：通过增加 50 毫秒的随机化时间，最坏的完成情况（1000 次尝试）只要 513 毫秒。<br>下面的图显示，通过减少选举超时时间可以减少系统的宕机时间。在选举超时时间为 12-24 毫秒的情况下，只需要平均 35 毫秒就可以选举出新的领导人（最长的一次花费了 152 毫秒）。然而，进一步降低选举超时时间的话就会违反 Raft 的时间不等式需求：在选举新领导人之前，领导人就很难发送完心跳包。这会导致没有意义的领导人改变并降低了系统整体的可用性。我们建议使用更为保守的选举超时时间，比如 150-300 毫秒；这样的时间不大可能导致没有意义的领导人改变，而且依然提供不错的可用性</p>
<h2 id="log-replication"><a href="#log-replication" class="headerlink" title="log replication"></a>log replication</h2><p>当有了 leader，系统应该进入对外工作期了。客户端的一切请求来发送到 leader，leader 来调度这些并发请求的顺序，并且保证 leader与 followers 状态的一致性。raft中的做法是，将这些请求以及执行顺序告知 followers。leader 和 followers以相同的顺序来执行这些请求，保证状态一致。</p>
<h3 id="Replicated-state-machines"><a href="#Replicated-state-machines" class="headerlink" title="Replicated state machines"></a>Replicated state machines</h3><p>共识算法的实现一般是基于复制状态机（Replicated state machines），何为复制状态机：<br>If two identical, deterministic processes begin in the same state and get the same inputs in the same order,<br>they will produce the same output and end in the same state</p>
<p>简单来说：相同的初识状态 + 相同的输入 &#x3D; 相同的结束状态。引文中有一个很重要的词deterministic，就是说不同节点要以相同且确定性的函数来处理输入，而不要引入一下不确定的值，比如本地时间等。如何保证所有节点 get the same inputs in the same order，使用replicated log是一个很不错的注意，log 具有持久化、保序的特点，是大多数分布式系统的基石。<br>因此，可以这么说，在raft中，leader将客户端请求（command）封装到一个个log entry，将这些log entries复制（replicate）到所有follower节点，然后大家按相同顺序应用（apply）log entry中的command，则各个节点的状态肯定是一致的。<br>下图形象展示了这种 log-based replicated state machine<br><img src="/.io//03/24/raft/state-machine.png"></p>
<h3 id="请求完整流程"><a href="#请求完整流程" class="headerlink" title="请求完整流程"></a>请求完整流程</h3><p>当系统（leader）收到一个来自客户端的写请求，到返回给客户端，整个过程从leader的视角来看会经历以下步骤：</p>
<ol>
<li>leader append log entry </li>
<li>leader issue AppendEntries RPC in parallel </li>
<li>leader wait for majority response </li>
<li>leader apply entry to state machine </li>
<li>leader reply to client </li>
<li>leader notify follower apply log<br>可以看到日志的提交过程有点类似两阶段提交(2PC)，不过与2PC的区别在于，leader只需要大多数（majority）节点的回复即可，这样只要超过一半节点处于工作状态则系统就是可用的。<br>那么日志在每个节点上是什么样子的呢</li>
</ol>
<p><img src="/.io//03/24/raft/log-in-node.png"><br>不难看到，logs由顺序编号的log entry组成 ，每个log entry除了包含command，还包含产生该log entry时的leader term。从上图可以看到，五个节点的日志并不完全一致，raft算法为了保证高可用，并不是强一致性，而是最终一致性，leader会不断尝试给follower发log entries，直到所有节点的log entries都相同。<br>在上面的流程中，leader只需要日志被复制到大多数节点即可向客户端返回，一旦向客户端返回成功消息，那么系统就必须保证log（其实是log所包含的command）在任何异常的情况下都不会发生回滚。<br>leader 将决定什么时候把一条 entry 应用到状态机是安全的，所谓安全就是一个 entry 的状态是 commited。<br>这里有两个 entry 的状态：<br>commit（committed）：日志被复制到了大多数节点后的状态<br>apply(applied)：节点将日志应用到自己状态机后的状态</p>
<blockquote>
<p>The leader decides when it is safe to apply a log entry to the state machines; such an entry is called committed. Raft guarantees that committed entries are durable and will eventually be executed by all of the available state machines. A log entry is committed once the leader that created the entry has replicated it on a majority of the servers<br>leader</p>
</blockquote>
<p>将一个 log entry 状态转换为 committed 后，这条 entry 之前的所有 log entries 都将被提交，包括其他 leader 创建的 entry。<br>leader 跟踪着最大的将会被提交的日志 index，这个 index 的值将放到未来所有 append Entries 的 rpc 请求中，这样 follower 就知道 leader 提交到什么位置了，follower 将会把这条 log entry 和之前的log entry 都 apply 到本地状态机中。</p>
<h3 id="log-matching【特性3】"><a href="#log-matching【特性3】" class="headerlink" title="log matching【特性3】"></a>log matching【特性3】</h3><p>日志匹配特性就是下面这两句话</p>
<blockquote>
<p>If two entries in different logs have the same index and term, then they store the same command.<br>If two entries in different logs have the same index and term, then the logs are identical in all preceding entries.</p>
</blockquote>
<p>第一条特性来源于：<br>一个任期至多一个leader，log entry 只能由 leader 产生，而一个 entry 一旦生成，他的位置绝对不会改变<br>第二条特性来源于：<br>leader 发送 append RPCs 时，会把新 log 前紧挨着的 log idx+term 也加到请求里。follower 假如接受到一次 appendEntry rpc，发现他找不到跟 previous 相同索引的条目，他就拒绝接受新条目；一致性检查就像一个归纳步骤：一开始空的日志状态肯定是满足日志匹配特性的，然后一致性检查在日志扩展的时候保护了日志匹配特性。因此，每当附加日志 RPC 返回成功时，领导人就知道跟随者的日志一定是和自己相同的了。<br>在正常的操作中，领导人和跟随者的日志保持一致性，所以附加日志 RPC 的一致性检查从来不会失败。然而，领导人崩溃的情况会使得日志处于不一致的状态（老的领导人可能还没有完全复制所有的日志条目）。这种不一致问题会在领导人和跟随者的一系列崩溃下加剧。<br><img src="/.io//03/24/raft/log-incons.png"><br>上图的例子会展示出不一致问题的一个场景<br>当一个领导人成功当选时，跟随者可能是任何情况（a-f）。每一个盒子表示是一个日志条目；里面的数字表示任期号。跟随者可能会缺少一些日志条目（a-b），可能会有一些未被提交的日志条目（c-d），或者两种情况都存在（e-f）。例如，场景 f 可能会这样发生，某服务器在任期 2 的时候是领导人，已附加了一些日志条目到自己的日志中，但在提交之前就崩溃了；很快这个机器就被重启了，在任期 3 重新被选为领导人，并且又增加了一些日志条目到自己的日志中；在任期 2 和任期 3 的日志被提交之前，这个服务器又宕机了，并且在接下来的几个任期里一直处于宕机状态。<br>raft 中 leader 通过强制 follower 复制自己的日志来处理不一致。这将导致 follower 与 leader 冲突的日志将会被 leader 所覆盖。有一个机制会保障这样做是安全的：下面 safety-安全性论证<br>leader 想让 follower 按照自己的日志进行，先要找到俩节点最后一个一致的地方X，删除 follower X之后的全部日志，然后复制自己X之后的给 follower。为此 leader 对每个 follower 维护了一个 nextIndex，标识下一个需要发送给某个 follower 的日志索引地址。当leader 刚刚选举完成，他会初始化所以 nextIndex 值为自己最后一条日志 index +1（上图中的 log index 11）。当 follower 接受appendEntry 一致性检查未通过时，leader 就会减小这个 follower 的 nextIndex 并重新 appendEntry。最终他们一定会到某个位置（appendEntry 成功），此时 follower 会把冲突的日志全部删除并加上领导人的日志。一旦 appendEntry 成功，接下来的任期中 follower 就会一直与 leader 日志一致。<br>算法可以优化：减少 rpc 的次数，follower 在拒绝 ae 请求时附带冲突任期号和最小索引，Leader 就可以少一个任期内的 nextIndex，但实践中发现这种优化压根没用，因为失败很少，并且也不太会出现大量不一致的日志<br>借助 log matching 这种实现的机制，leader 一旦选出，就不需要任何操作来恢复一致性。他本身就正常操作，日志在 appendEntry 到 follower 的过程中自动趋于一致。leader 本身不会覆盖或删除自己的日志，只会追加【特性2 领导人只附加原则】<br>总结一下日志匹配特性是如何做到的：<br>leader会维护一个nextIndex[]数组，记录了leader可以发送每一个follower的log index，初始化为eader最后一个log index加1， 前面也提到，leader选举成功之后会立即给所有follower发送AppendEntries RPC（不包含任何log entry， 也充当心跳消息）,那么流程总结为：<br>s1 leader 初始化nextIndex[x]为 leader最后一个log index + 1<br>s2 AppendEntries里prevLogTerm prevLogIndex来自 logs[nextIndex[x] - 1]<br>s3 如果follower判断prevLogIndex位置的log term不等于prevLogTerm，那么返回 False，否则返回True<br>s4 leader收到follower的回复，如果返回值是False，则nextIndex[x] -&#x3D; 1, 跳转到s2. 否则<br>s5 同步nextIndex[x]后的所有log entries</p>
<h2 id="safety"><a href="#safety" class="headerlink" title="safety"></a>safety</h2><p>解释一下之前流程中在异常情况下如何保证安全<br>本质上就是在选举、日志复制时增加一些限制。<br>最后说一下 Leader Completeness Property（特性4） 是如何引导复制状态机做出正确行为的</p>
<h3 id="选举限制"><a href="#选举限制" class="headerlink" title="选举限制"></a>选举限制</h3><p>任何一致性算法中，leader 都必须存储所有提交过的日志。很多算法（如 Viewstamped Replication）要么是在选举阶段通过额外机制识别丢失的日志并把他们传给新 leader，要么是在选举之后很快进行，这都会对选举增加很大的复杂性。<br>requestVote rpc 增加一个限制，在请求中包含了候选人的日志信息，投票者会拒绝日志没有自己新的投票。<br>怎么定义新：通过比较两份日志最后一条的 index 就能知道谁的日志最新（任期越大越新+日志越长越新）</p>
<h3 id="提交之前任期的日志"><a href="#提交之前任期的日志" class="headerlink" title="提交之前任期的日志"></a>提交之前任期的日志</h3><p><img src="/.io//03/24/raft/term-no-only.png" alt="leader 无法决定之前任期的例子"><br>原文:<br>为了消除上图的情况，raft 拥有不会通过计算副本数去提交一个之前任期的日志。只有领导人当前任期里的日志条目通过计算副本数目可以被提交；一旦当前任期的日志条目以这种方式被提交，那么由于日志匹配特性，之前的日志条目也都会被间接的提交。在某些情况下，领导人可以安全的知道一个老的日志条目是否已经被提交（例如，该条目是否存储到所有服务器上），但是 Raft 为了简化问题使用一种更加保守的方法。<br>我的理解:<br>某个leader选举成功之后，不会直接提交前任leader时期的日志，而是通过提交当前任期的日志的时候“顺手”把之前的日志也提交了。流程就和 log matching 部分一样，nextIndex[] 的那招。<br>那么问题来了，如果leader被选举后没有收到客户端的请求呢，论文中有提到，在任期开始的时候发立即尝试复制、提交一条空的log，也就是说刚选出来其实立马就开始递归式的 appendEntry 了。带入到上图中(c)的情况，假设 s1 刚选举成功时没有新的 4 term 的客户端输入，那么他第一次广播时就在同步 term2 了；</p>
<blockquote>
<p>Raft handles this by having each leader commit a blank no-op entry into the log at the start of its term.</p>
</blockquote>
<p>因此，在上图中，不会出现（C）时刻的情况，即 term4任期的leader s1不会复制term2的日志到s3。而是如同(e)描述的情况，通过复制-提交 term4的日志顺便提交term2的日志。如果term4的日志提交成功，那么term2的日志也一定提交成功，此时即使s1crash，s5也不会重新当选，因为超过半数的 node term 已经高于 s5了。<br>所以这个特性是保证 raft 内部能一致，与客户端的信息无关。因为在上图中客户端视角应该是连续的会断开链接，不知道提没提交过。但是可以用get的方式来确认是否提交过。<br>反过来看日志的角度，丢弃的都是没被 commit 过的日志，没 commit 过的日志也会因为 leader crash 而 commit。</p>
<h3 id="安全性论证"><a href="#安全性论证" class="headerlink" title="安全性论证"></a>安全性论证</h3><p>在给定了完整的 Raft 算法之后，我们现在可以更加精确的讨论领导人完整性特性（这一讨论基于 9.2 节的安全性证明）。<br>我们假设领导人完全性特性是不存在的，然后我们推出矛盾来。假设任期 T 的领导人（领导人 T）在任期内提交了一条日志条目，但是这条日志条目没有被存储到未来某个任期的领导人的日志中。<br>设大于 T 的最小任期 U 的领导人 U 没有这条日志条目。<br><img src="/.io//03/24/raft/safety.png"></p>
<blockquote>
<p>如果 S1 （任期 T 的领导人）在它的任期里提交了一条新的日志，然后 S5 在之后的任期 U 里被选举为领导人，那么至少会有一个机器，如 S3，既拥有来自 S1 的日志，也给 S5 投票了。</p>
</blockquote>
<ol>
<li>在领导人 U 选举的时候一定没有那条被提交的日志条目（领导人从不会删除或者覆盖任何条目）。</li>
<li>领导人 T 复制这条日志条目给集群中的大多数节点，同时，领导人 U 从集群中的大多数节点赢得了选票。因此，至少有一个节点（投票者、选民）同时接受了来自领导人 T 的日志条目，并且给领导人 U 投票了，如图 9。这个投票者是产生这个矛盾的关键。 </li>
<li>这个投票者必须在给领导人 U 投票之前先接受了从领导人 T 发来的已经被提交的日志条目；否则他就会拒绝来自领导人 T 的附加日志请求（因为此时他的任期号会比 T 大）。 </li>
<li>投票者在给领导人 U 投票时依然保存有这条日志条目，因为任何中间的领导人都包含该日志条目（根据上述的假设），领导人从不会删除条目，并且跟随者只有在和领导人冲突的时候才会删除条目。 </li>
<li>投票者把自己选票投给领导人 U 时，领导人 U 的日志必须和投票者自己一样新。这就导致了两者矛盾之一。 </li>
<li>首先，如果投票者和领导人 U 的最后一条日志的任期号相同，那么领导人 U 的日志至少和投票者一样长，所以领导人 U 的日志一定包含所有投票者的日志。这是另一处矛盾，因为投票者包含了那条已经被提交的日志条目，但是在上述的假设里，领导人 U 是不包含的。 </li>
<li>除此之外，领导人 U 的最后一条日志的任期号就必须比投票人大了。此外，他也比 T 大，因为投票人的最后一条日志的任期号至少和 T 一样大（他包含了来自任期 T 的已提交的日志）。创建了领导人 U 最后一条日志的之前领导人一定已经包含了那条被提交的日志（根据上述假设，领导人 U 是第一个不包含该日志条目的领导人）。所以，根据日志匹配特性，领导人 U 一定也包含那条被提交的日志，这里产生矛盾。 </li>
<li>这里完成了矛盾。因此，所有比 T 大的领导人一定包含了所有来自 T 的已经被提交的日志。 </li>
<li>日志匹配原则保证了未来的领导人也同时会包含被间接提交的条目，例如图 8 (e) 中的索引 2。</li>
</ol>
<p>经过上面的论证，结合 【特性4 领导人完全特性】保证高 term leader 会存储相同的 log，<br>验证了 【特性5 状态机安全特性：如果服务器已经在某个给定的索引值应用了日志条目到自己的状态机里，那么其他的服务器不会应用一个不一样的日志到同一个索引值上；在一个服务器应用一条日志条目到他自己的状态机中时，他的日志必须和领导人的日志，在该条目和之前的条目上相同，并且已经被提交】成立</p>
<h2 id="crash"><a href="#crash" class="headerlink" title="crash"></a>crash</h2><p>candidate 和 follower crash 后，后续发给他们的 rpc 都会失败。raft 中处理失败调用的策略就是无限次重试。当他们恢复后，那么这些rpc就恢复应该的结果了。如果一个服务器完成了一个rpc但没响应就 crash 了，在他重启之后会再次收到同意的请求。raft 的rpc 全是幂等的。比如 appendEntry：无非是第一次接受到就 commit，第二次忽略这次 rpc 罢了。</p>
<h2 id="时间和可用性"><a href="#时间和可用性" class="headerlink" title="时间和可用性"></a>时间和可用性</h2><p>raft 的正常工作（append log）是不依赖时间的，但是可用性不可避免的依赖时间。比如信息交换比服务器故障的超时还长，候选人就永远没可能有足够时间赢得选举了。<br>所以依赖时间的地方就是leader election。为了选举并维持一个稳定的leader，系统需要满足以下时间要求：<br><strong>广播时间（broadcastTime） &lt;&lt; 选举超时时间（electionTimeout） &lt;&lt; 平均故障间隔时间（MTBF）</strong><br>广播就是正常的rpc调用<br>选举就是 random 150-300 ms 的值<br>平均故障就是连续两次故障的平均时间（集群里一堆机器起了就挂，还没到选举完成就挂，也无法维持一个稳定leader）<br>广播时间和平均故障间隔时间是由系统决定的，但是选举超时时间是我们自己选择的。Raft 的 RPCs 需要接收方将信息持久化的保存到稳定存储中去，所以广播时间大约是 0.5 毫秒到 20 毫秒，取决于存储的技术。因此，选举超时时间可能需要在 10 毫秒到 500 毫秒之间。大多数的服务器的平均故障间隔时间都在几个月甚至更长，很容易满足时间的需求。</p>
<h2 id="变配"><a href="#变配" class="headerlink" title="变配"></a>变配</h2><p>变更集群配置是时有发生的，比如替换宕机的机器，修改复制级别。停机下配重启是最弱的实现，而且手工操作会误操作，raft 使用自动化的配置修改机制变更。</p>
<h3 id="配置修改机制"><a href="#配置修改机制" class="headerlink" title="配置修改机制"></a>配置修改机制</h3><p>一次性原子性的修改全部服务器是不可能的，这也导致一些不安全性（比如配置一变，导致2个leader被选出）<br><img src="/.io//03/24/raft/joint-cons.png"><br>直接从一种配置转到新的配置是十分不安全的，因为各个机器可能在任何的时候进行转换。在这个例子中，集群配额从 3 台机器变成了 5 台。不幸的是，存在这样的一个时间点，两个不同的领导人在同一个任期里都可以被选举成功。一个是通过旧的配置，一个通过新的配置。<br>备注：S1 S2 用老配置选 S2 当了 leader；S3 S4 S5 用新配置选 S3 当了 leader<br>所以为了安全，必须用2阶段方案。raft 的方法是先将集群切换到一个共同一致状态（joint consensus），一旦共同一致被提交，系统就切换到新配置。</p>
<h3 id="共同一致"><a href="#共同一致" class="headerlink" title="共同一致"></a>共同一致</h3><p>是新老配置的结合：</p>
<ol>
<li>日志条目被复制给集群中新、老配置的所有服务器。</li>
<li>新、旧配置的服务器都可以成为领导人。</li>
<li>达成一致（针对选举和提交）需要分别在两种配置上获得大多数的支持。</li>
</ol>
<p>共同一致允许独立的服务器在不影响安全性的前提下，在不同的时间进行配置转换过程。此外，共同一致可以让集群在配置转换的过程中依然响应客户端的请求。<br>集群配置在复制日志中以特殊的日志条目来存储和通信。<br>有一个潜在的约定：<strong>服务器总是使用最新的配置，无论他是否已经被提交</strong><br>leader 接受到 C-old 变配 C-new 请求后，会存储一个 C-old,new 的『共同一致』日志，以后就用这个配置来做出未来的决定。如果此时 leader crash，新的 leader 只可能处于 C-old 或者 C-old,new，也就是说任何情况下C-new 在这个阶段不会单方面做出决定。<br>C-old,new 被提交后，无论 C-old 还是 C-new，如果不经过另一个配置允许都不能单独做出决定，并且领导人完全特性保证了 包含 C-old,new 的条目的节点才能成为 leader，此时领导人创建一条关于 C-new 配置的日志并复制给集群就安全了。任何服务器 接到 C-new 后就会立刻按照 C-new 生效，等于旧配置的机器会在接到 C-new 的瞬间而失效。</p>
<h3 id="额外引入的三个问题"><a href="#额外引入的三个问题" class="headerlink" title="额外引入的三个问题"></a>额外引入的三个问题</h3><ol>
<li>新服务器刚进入集群，没有任何日志，需要追赶一阵子的日志，此时不能提交新条目了。<br>答： raft 在配置更新前还有一个额外的阶段：新服务器以没有投票权的身份加入到集群（只接受 log replica，但 leader 不考虑他们 是大多数）。一旦新服务器追上了新日志条目，他就会进入重新配置的阶段。</li>
<li>leader 在重配阶段crash，新 leader 可能不是新配置的一员。<br>答：假如 leader 按照 C-old 被选出，他会在提交 C-new 之后自己转回 follower。因为 C-new 已经提交，下一次选举一定会选择包含C-new 的节点作为leader。</li>
<li>移除不在 C-new 服务器可能会扰乱集群。因为这些服务器不会再接受心跳，当选举超时，他们就会发起新的选举，产生新的term 和广播 requestVote，会导致当前 leader 退回 follower 。移出的 node 因为不在配置里，没人投给他，但是就算其他正常的节点选成新 leader，都会面临 移除节点 无限的超时重选，集群的可用性将大幅降低。<br>答：当服务器确定当前 leader 存在时（正常leader 会一直发心跳，而心跳的间隔比最小选举超时时间短的多），直接忽略外来的 requestVote rpc。正常的选举至少要在选举超时后才有可能进行，突然来一个 requestVote 对任何可用节点都是没用的。</li>
</ol>
<h2 id="日志压缩"><a href="#日志压缩" class="headerlink" title="日志压缩"></a>日志压缩</h2><p>和 chubby&#x2F;zookeeper 一样，将一个时间点前的日志合并成一个小的 snapshot，然后丢弃这个时间点前到日志。<br><img src="/.io//03/24/raft/log-compress.png"><br>一个服务器用新的快照替换了从 1 到 5 的条目，快照值存储了当前的状态。快照中包含了最后的索引位置和任期号。<br>快照生成和日志清除都没啥可说的，增量压缩已经很成熟了。<br>但偶尔会出现 leader 复制 snapshot 给一些落后过多的 follower（比如 leader 丢失了某个 follower 的 nextIndex；或者新加了一个没任何日志的服务器），此时会通过网络发 snapshot 并将 leader 内的 nextIndex[$lostNode] 写成 snapshot.lastIndex+1<br>raft 提供了一个 安装快照的 rpc 接口<br><img src="/.io//03/24/raft/snapshot-rpc.png"><br>快照技术是违背 raft 强 leader 原则的，因为 follower 接到请求（无论哪儿来的）就能创建快照，但是 raft 团队认为违背就违背了。<br>为了优化写入快照性能，raft 利用了类似 linux fork 的写时复制技术创建状态机的内存快照。</p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p><strong>客户端只能跟leader交互</strong></p>
<ol>
<li>客户端随便访问一个节点A </li>
<li>假如A不是 leader，返回 leader 地址 </li>
<li>假如 leader 已经 crash，客户端就会超时，进而继续随机挑选节点发送请求<br>重复执行问题：客户端调了一下 leader，leader 提交了这条日志，还没返回给客户端就 crash 了，这时客户端应该会到新 leader 重试一样的命令，导致命令重复了。<br>答：客户端每一条指令都会赋予一个唯一的序列号，状态机会追踪每条指令最新的序列号，这个序列号会在 commit 时存储，新leader 肯定是知道一个命令是不是commit过的，如果已经有一样序列号的指令，直接返回结果，而不是重复执行。<br>只读操作在不加任何限制时可能会收到脏数据（响应client 的 leader 在响应到一半的时候可能已经不是 leader 了），raft 里两个特性保证了在不使用日志的情况下，client 读不到脏数据： </li>
<li>领导人完全特性：leader 一旦选出，他一定有最新的提交的日志【通过刚当选就广播一次空log的 appendEntry，他就知道本地哪些日志提交过，哪些没有】 </li>
<li>leader 处理只读消息前检查自己是否已经被废黜（有新 leader 当选，旧 leader 的信息可能就是脏数据，因为新 leader 可能已写入更新的条目了），方法就是在接受请求一上来就广播一次心跳。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="与-paxos-的区别"><a href="#与-paxos-的区别" class="headerlink" title="与 paxos 的区别"></a>与 paxos 的区别</h3><p>raft 是强领导特性的分布式一致性算法，将更多的功能集中到 leader 简化了方案，随之也就简化了理解难度。<br>paxos 的 leader 选举是性能优化的手段，并不是他一致性必要的步骤。所以他本身的一致性算法有更多的机制，比如改造的2PC等，导致理解难度高。</p>
<h3 id="正确性"><a href="#正确性" class="headerlink" title="正确性"></a>正确性</h3><p>RAMCLOUD 有一个 2000 行代码的 C++的实现，帮助 RAMCloud 完成存储配置信息 FSM，并帮助 RAMCloud 协调 failover。<br>同时有一篇3500字的论文证明了安全性是完备的</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>核心就是 leader 选举成功后复制条目的性能。raft 的消息包比较少，并不太影响性能。<br>增加了随机选举超时，改善了宕机重选的时间，这也增加了系统 SLA。</p>
<h2 id="考试题"><a href="#考试题" class="headerlink" title="考试题"></a>考试题</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/268571088">https://zhuanlan.zhihu.com/p/268571088</a><br>问题有一些有点烂,说不明白,看看就好</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Sam Bie</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://dive2cloud-bmz.github.io/2025/03/24/raft/">https://dive2cloud-bmz.github.io/2025/03/24/raft/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">Sam Bie</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">
                                    <span class="chip bg-color">分布式</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2025/03/25/ddd/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/12.jpg" class="responsive-img" alt="ddd">
                        
                        <span class="card-title">ddd</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2025-03-25
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            Sam Bie
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/DDD/">
                        <span class="chip bg-color">DDD</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2025/03/23/3PC/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/6.jpg" class="responsive-img" alt="3PC">
                        
                        <span class="card-title">3PC</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2025-03-23
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            Sam Bie
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">
                        <span class="chip bg-color">分布式</span>
                    </a>
                    
                    <a href="/tags/3PC/">
                        <span class="chip bg-color">3PC</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('88')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE' || selection.getRangeAt(0).commonAncestorContainer.nodeName === 'CODE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: BMZ BLOG<br />'
            + '文章作者: Sam Bie<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>



<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2025</span>
            
            <a href="/about" target="_blank">Sam Bie</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
            <br>
            
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                        class="white-color">67k</span>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/dive2cloud-bmz" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:biemingzhou@163.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>













    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
    
    
        
        <script type="text/javascript">
            // 只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="/libs/others/sakura.js"><\/script>');
            }
        </script>
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
